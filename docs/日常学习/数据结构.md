---
title: 数据结构
tags:
  - 笔记
  - 学习
  - 待续
permalink: /article/blh4xhyz/
createTime: 2024/05/09 15:43:06
---
# 第一章



## 数据结构研究的内容



- 无法用数学的公式或方程来描述，使一些“**非数值计算**”的程序设计问题。
- 描述非数值计算问题的数学模型不是数学方程，而是诸如**表**、**树**和**图**之类的具有**逻辑关系**的数据。
- 数据结构是一门研究**非数值计算**的程序设计中计算机的**操作对象**以及它们之间的**关系**和**操作**的学科。



## 基本概念和术语



### 数据（Data）



- 是能输入计算机且能被计算机处理的各种符号的集合
  - 信息的载体
  - 是对客观事物符号化的表示
  - 能够被计算机识别、存储和加工
- 包括：
  - 数值型数据：整数、实数等
  - 非数值型数据：文字、图像、图形、声音等



### 数据元素（Data element）



- 是数据的**基本单位**，在计算机程序中通常作为一个整体进行考虑和处理
- 也称为元素，或成为记录、节点或顶点
- 一个数据元素可由若干个数据项组成



### 数据项（Data Item）



> 构成数据元素的不可分割的**最小单位**



### 三者关系



> 数据>数据元素>数据项



### 数据对象（Data Object）



> 是性质相同的数据元素的集合，是数据的一个子集



### 数据元素与数据对象



- 数据元素
  - 组成数据的基本单位
  - 与数据的关系：是集合的个体
- 数据对象
  - 性质相同的数据元素的集合
  - 与数据的关系：集合的子集



### 数据结构（Data Structure）



- 数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为**结构**（Structure）
- 是指相互之间存在一种或多种特定关系的数据元素集合
- 或者说，数据结构是带结构的数据元素的集合



> 数据结构包括以下三个方面的内容：
>
> 1. 数据元素之间的逻辑关系，也被称为逻辑结构
> 2. 数据元素及其关系在计算机内存中的表示（又称为映像），称为数据的物理结构或数据的存储结构
> 3. 数据的运算和实现，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现



> 数据结构的两个层次：
>
> - 逻辑结构
>   - 描述数据元素之间的逻辑关系
>   - 与数据的存储无关,独立于计算机
>   - 是从具体问题抽象出来的数学模型
> - 物理结构（存储结构）
>   - 数据元素及其关系在计算机存储器中的结构（存储方式）
>   - 是数据结构在计算机中的表示
> - 逻辑结构与存储结构的关系
>   - 存储结构是逻辑关系的映象与元素本身的映象
>   - 逻辑结构是数据结构的抽象,存储结构是数据结构的实现
>   - 两者综合起来建立了数据元素之间的结构关系



### 逻辑结构的种类



划分方式一：

- 线性结构

  有且仅有一个开始和一个终端结点，并且所有结点最多只有一个直接前趋和一个直接后继。

  例如：线性表、栈、队列、串

- 非线性结构

  一个结点可能有多个直接前趋和直接后继。

  例如：树、图



划分方式二——四类基本逻辑结构：

1. 集合结构：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。
2. 线性结构：结构中的数据元素之间存在着一对一的线性关系。
3. 树形结构：结构中的数据元素之间存在着一对多的层次关系。
4. 图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。



### 存储结构的种类



四种基本的存储结构：

- 顺序存储结构

  - 用一组连续的存储单依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。
  - C语言中用数组来实现顺序存储结构。

- 链式存储结构

  - 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。
  - C语言中用指针来实现链式存储结构。

- 索引存储结构

  - 在存储结点信息的同时，还建立附加的索引表。
  - 索引表中的每一项称为一个索引项。
  - 索引项的一般形式是：（关键字，地址）
  - 关键字是能唯一标识一个结点的那些数据项。
  - 若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引（Dense Index）。若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引（Sparse Index）。

- 散列存储结构

  根据结点的关键字直接计算出该结点的存储地址。



### 数据类型（Data Type）



定义：数据类型是一组性质相同的**值的集合**以及定义于这个值集合上的一组操作的总称。

数据类型=值的集合+值集合上的一组操作



- 在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的数据类型。
- 例如，C语言中：
  - 提供int，char，float，double等基本数据类型
  - 数组、结构、共用体、枚举等构造数据类型
  - 还有指针、空（void）类型
  - 用户也可用typedef自己定义数据类型
- 一些最基本数据结构可以用数据类型来实现，如数组、字符串等。
- 而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。



> 高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。
>
> 例如，C语言中定义变量i为int类型，就表示i是[-min,max]范围的整数，在这个整数集上可以进行+、-、*、\、%等操作



数据类型的作用

- 约束变量或常量的取值范围
- 约束变量或常量的操作



### 抽象数据类型（Abstract Data Type，ADT）



是指一个数学模型以及定义在此数学模型上的一组操作

- 由用户定义从问题抽象出数据模型（逻辑结构）
- 还包括定义在数据模型上的一组抽象运算（相关操作）
- 不考虑计算机内的具体存储结构与运算的具体实现算法



> 抽象数据类型的形式定义：
>
> 抽象数据类型可用（D，S，P）三元组表示。
>
> 其中：
>
> - D是数据对象
> - S是D上的关系集
> - P是对D的基本操作集



一个抽象数据类型的定义格式如下：

```
ADT 抽象数据类型名{
	数据对象:<数据对象的定义>
	数据关系:<数据关系的定义>
	基本操作:<基本操作的定义>
} ADT 抽象数据类型名
```

其中：

- 数据对象、数据关系的定义用伪代码描述
- 基本操作的定义格式为：
  - 基本操作名（参数表）
  - 初始条件：<初始条件描述>
  - 操作结果：<操作结果描述>



基本操作定义格式说明：

- 参数表：赋值参数只为操作提供输入值。

  引用参数以&打头，除可提供输入值外，还将返回操作结果。

- 初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空,则省略之。

- 操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。



定义举例（Circle的定义）



```
ADT Circle{
	数据对象: D={r,x,y|r,x,y均为实数}
	数据关系: R={<r,x,y>|r是半径，<x,y>是圆心坐标}
	基本操作:
	Circle(&C,r,x,y)
		操作结果: 构造一个圆
	double Area(C)
		初始条件: 圆已存在
		操作结果: 计算面积
	double Circumference(C)
		初始条件: 圆已存在
		操作结果: 计算周长
	……
}ADT Circle
```



### 抽象数据类型的表示与实现



抽象数据类型可以通过固有的数据类型（如整型、实型、字符型等）来表示和实现。

即利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作。



### 小结



![image-20210911095923043](/Users/jiyuan/Library/Application%20Support/typora-user-images/image-20210911095923043.png)



## 算法和算法分析



### 算法



#### 定义



对特定问题求解方法和步骤的一种描述，它是指令的优先序列。其中，每个指令表示一个或多个操作。

简而言之，算法就是解决问题的方法和步骤。



#### 描述



- 自然语言：英语、中文
- 流程图：传统流程图、NS流程图
- 伪代码：类语言：类C语言
- 程序代码：C、JAVA



#### 算法与程序



- 算法是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法。
- 程序是用某种程序设计语言对算法的具体实现。

- 程序=数据结构+算法

- 数据结构通过算法实现操作
- 算法根据数据结构设计程序



#### 特性



- 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。
- 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。
- 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。
- 输入一个算法有零个或多个输入。
- 输出一个算法有一个或多个输出。



#### 要求



- 正确性

  算法满足问题要求，能正确解决问题算法转化为程序后要注意：

  1. 程序中不含语法错误
  2. 程序对于几组输入数据能够得出满足要求的结果
  3. 程序对于精心选择的、典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果
  4. 程序对于一切合法的输入数据都能得出满足要求的结果

  通常以第三层意义上的正确性作为衡量一个算法是否合格的标准。

- 可读性

  1. 算法主要是为了人的阅读和交流，其次才是为计算机执行，因此算法应该易于人的理解
  2. 另一方面，晦涩难读的算法易于隐藏较多错误而难以调试

- 健壮性

  1. 指当输入非法数据时，算法恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果
  2. 处理出错的方法，不应是中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理

- 高效性

  要求花费尽量少的时间和尽量低的存储要求



### 算法分析



算法分析的目的是看算法实际是否可行，并在同一问题存在多个算法时可进行性能上的比较，以便从中挑选出比较优的算法。



- 一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。

- 算法效率以下两个方面来考虑：
  1. 时间效率：指的是算法所耗费的时间。
  2. 空间效率：指的是算法执行过程中所耗费的存储空间。
  3. 时间效率和空间效率有时候是矛盾的。



#### 算法时间效率的度量



- 算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。

- 两种度量方法

  - 事后统计

    将算法实现测算其时间和空间开销

    缺点：编写程序实现算法将花费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣

  - 事前分析

    对算法所消耗资源的一种估算方法



#### 事前分析方法

- 一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的时间与算法中进行的简单操作次数乘积。

  算法运行时间=一个简单操作所需的时间*简单操作次数

- 也即算法中每条语句的执行时间之和
  $$
  \text{算法运行时间}=\sum{\text{每条语句的执行次数（语句频度）}\times\text{该语句执行一次所需的时间}}
  $$
  每条语句执行一次所需的时间，一般是随机器而异的。取决于机器的指令性能、速度以及编译的代码质量。是由机器本身软硬件环境决定的，它与算法无关。

  所以，我们可假设执行每条语句所需的时间均为单位时间。此时对算法的运行时间的讨论就可转化为讨论该算法中所有语句的执行次数，即频度之和了。

  这就可以独立于不同机器的软硬件环境来分析算法的时间性能了。



```js
// 例如：两个n*n矩阵相乘的算法可描述为：
for(let i=1;i<=n;i++){ // n+1
  for(let j=1;j<=n;j++){ // n*(n+1)
		c[i][j]=0; // n*n
    for(let k=0;i<n;k++){ // n*n*(n+1)
			c[i][j]=c[i][j]+a[i][k]*b[k][j]; // n*n*n
    }
  }
}
```

我们把算法所耗费的时间定义为该算法中每条语句的频度之和，则上述算法的时间消耗T(n)为：
$$
T(n)=2n^3+3n^2+2n+1
$$


#### 算法时间复杂度



- 为了便于比较两个不同算法的时间效率，我们仅比较他们的数量级

  例如：两个不同的算法，时间消耗分别是：
  $$
  T_1(n)=10n^2 \quad \text{与}\quad T_2(n)=5n^3
  $$

- 若有某个辅助函数$f(n)$，使得当n趋近于无穷大时，$T(n)/f(n)$的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作$T(n)=O(f(n))$，称$O(f(n))$为算法的渐进时间复杂度（O是数量级的符号），简称**时间复杂度**。


$$
T(n)=2n^3+3n^2+2n+1
$$

$$
n→\infty\text{时，}T(n)/n^3→2\text{，这表示n充分大时，}T(n)\text{与}n^3\text{是同阶或同数量级，引入O记号，则}T(n)\text{可记作：}
$$

$$
T(n)=O(n^3)
$$

这就是求解矩阵相乘问题的算法的渐进时间复杂度。

一般情况下，不必计算所有操作的执行次数，而只考虑算法中的基本操作执行的次数，它是问题规模n的某个函数，用T(n)表示。



算法中**基本语句重复执行的次数**是**问题规模n**的某个函数f(n)，算法的时间度量记作：
$$
T(n)=O(f(n))
$$
它表示随着n的增大，算法执行的时间增长率和f(n)的增长率相同，称**渐进时间复杂度**。



> 数学符号“O”的定义为：
>
> 若$T(n)$和$f(n)$是定义在正整数集合上的两个函数，则$T(n)=O(f(n))$表示存在正的常数C和$n_0$，使得当$n\geq n_0$时都满足$0\leq T(n)\leq Cf(n)$。



基本语句：

- 算法中重复执行次数和算法的执行时间成正比的语句
- 对算法运行时间的贡献最大
- 执行次数最多



问题规模n：

- n越大算法的执行时间越长
- 排序：n为记录数
- 矩阵：n为矩阵的阶数
- 多项式：n为多项式的项数
- 集合：n为元素个数
- 树：n为树的结点个数
- 图：n为图的顶点数或边数



时间复杂度是由嵌套最深层语句的频度决定的。



例题：分析以下程序的时间复杂度

```js
var i = 1;
while(i<=n){
  i=i*2
}
```

关键是要找出来执行次数x与n的关系，并表示成n的函数。

- 若循环执行一次：$i=1*2=2$
- 若循环执行两次：$i=2*2=2^2$
- 若循环执行三次：$i=2^2*2=2^3$
- 若循环执行n次：$i=2^{n-1}*2=2^n$

设语句`i=i*2`执行的次数是x次，由循环条件`i<=n`，所以$2^x<=n$，所以$x<=\log_2n$

$2^{f(n)}\leq n$，即$f(n)\leq \log_2n$

所以该段程序的时间复杂度$T(n)=O(\log_2n)$



有的情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同。

- 最坏时间复杂度：指在最坏情况下,算法的时间复杂度。
- 平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。
- 最好时间复杂度：指在最好情况下，算法的时间复杂度。
- 一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。



对于复杂的算法可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度。

- 加法法则
  $$
  T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
  $$

- 乘法法则
  $$
  T(n)=T1(n)\times T2(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))
  $$



算法时间效率的比较：

- 当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊

- 时间复杂度$T(n)$按数量级递增顺序为：

  | 复杂度低 | 常数阶 | 线性阶     | 线性对数阶    | 平方阶   | 立方阶   | ……   | K次方阶  | 指数阶   | 复杂度高 |
  | -------- | ------ | ---------- | ------------- | -------- | -------- | ---- | -------- | -------- | -------- |
  |          | $O(n)$ | $O\log_2n$ | $O(n\log_2n)$ | $O(n^2)$ | $O(n^3)$ |      | $O(n^k)$ | $O(2^n)$ |          |



#### 渐进空间复杂度



空间复杂度：算法所需存储空间的度量，记作：
$$
S(n)=O(f(n))
$$
其中n为问题的规模（或大小）

算法要占据的空间

- 算法本身要占据的空间，输入/输出，指令，常数，变量等
- 算法要使用的辅助空间



【例】将一维数组a中的n个数逆序存放到原数组中。

```js
// 算法1 S(n)=O(1) 原地工作
for(var i = 0;i<n/2;i++){
  let t = a[i];
  a[i]=a[n-i-1];
  a[n-i-1]=t;
}
// 算法2 S(n)=O(n)
for(let i = 0; i<n;i++){
  b[i]=a[n-i-1];
}
for(let j = 0; j<n;j++){
  a[j]=b[j];
}
```



### 设计算法的过程



![image-20210912160401167](/Users/jiyuan/Library/Application%20Support/typora-user-images/image-20210912160401167.png)



# 第二章



## 线性表的定义和特点



线性表是具有相同特性的数据元素的一个优先序列。

![image-20210912211131260](/Users/jiyuan/Library/Application%20Support/typora-user-images/image-20210912211131260.png)



### 定义



- 由$n(n\geq 0)$个数据元素（结点）$a_1,a_2,...a_n$组成的优先序列。
- 其中数据元素的个数n定义为表的长度。
- 当n=0时称为空表。
- 将非空线性表（n>0）记作：$(a_1,a_2,...a_n)$
- 这里的数据元素$a_i(1\leq i\leq n)$只是一个抽象的符号，其具体含义在不同的情况下可以不同。



同一线性表中的元素必定具有相同特性，数据元素之间的关系是线性关系。

以物理位置相邻表示逻辑关系。

任一元素均可随机存取。



### 特征



- 在非空的线性表，有且仅有一个开始结点$a_1$，它没有直接前趋，而仅有一个直接后继$a_2$
- 有且仅有一个终端结点$a_n$，它没有直接后继，而仅有一个直接前趋$a_{n-1}$
- 其余的内部结点$a_i(2\leq i\leq n-1)$都有且仅有一个直接前趋$a_{i-1}$和一个直接后继$a_{i+1}$
- 线性表是一种典型的线性结构



> 线性表中数据元素的类型可以为简单类型，也可以为复杂类型。
>
> 许多实际应用问题所设计的基本操作有很大相似性，不应为每个具体应用单独表写一个程序。
>
> 从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型），然后实现其存储结构和基本操作。



## 线性表的类型定义



![image-20210913101309872](/Users/jiyuan/Library/Application%20Support/typora-user-images/image-20210913101309872.png)



- InitList(&L)

  操作结果：构造一个空的线性表L

- DestroyList(&L)

  初始条件：线性表L已经存在

  操作结果：销毁线性表

- ClearList(&L)

  初始条件：线性表L已经存在

  操作结果：将线性表L重置为空

- ListEmpty(L)

  初始条件：线性表L已经存在

  操作结果：若线性表L为空表，则返回TRUE，否则返回FALSE

- ListLength(L)

  初始条件：线性表L已经存在

  操作结果：返回线性表L中的数据元素个数

- GetElem(L,i&e)

  初始条件：线性表L已经存在，$1\leq i\leq listLength(L)$

  操作结果：用e返回线性表L中第i个数据元素的值

- LocateElem(L,e,compare())

  初始条件：线性表L已经存在，compare()是数据元素判定函数

  操作结果：返回L中第一个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。

- PriorElem(L,cur_e,&pre_e)

  初始条件：线性表L已经存在

  操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义

- NextElem(L,cur_e,&next_e)

  初始条件：线性表L已经存在

  操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败；next_e无意义

- ListInsert(&L,i,e)

  初始条件：线性表L已经存在，$1\leq i\leq listLength(L)+1$

  操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加1

- ListDelete(&L,i,&e)

  初始条件：线性表L已经存在，$1\leq i\leq listLength(L)$

  操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一

- ListTraverse(&L,visited())

  初始条件：线性表L已经存在

  操作结果：依次对线性表中的每个元素调用visited()



## 线性表的顺序表示和实现



### 线性表的顺序存储表示



线性表的顺序表示又称为顺序存储结构或顺序映像。

顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。

简言之，逻辑上相邻，物理上也相邻。

线性表的第一个数据元素的存储位置，称作线性表的起始位置或基地址。



> 线性表顺序存储结构占用一片连续的存储空间。知道某个元素的存储位置就可以计算其他元素的存储位置。



- 顺序表（元素）

  - 地址连续
  - 依次存放
  - 随即存取
  - 类型相同

- 线性表长可变（删除）

- 数组（元素）

  用一维数组表示顺序表

  数组长度不可动态定义

  用变量表示顺序表的长度属性



```
#define LIST_INT_SIZE 100 //线性表存储空间的初始分配
typedef struct{
	ElemType elem[LIST_INT_SIZE];
	int length; //当前长度
}SqList
```



### 顺序表中元素存储位置的计算



建设线性表的每个元素需占$l$个存储单元，则第$i+1$个数据元素的存储位置和第$i$个元素的存储位置之间满足关系：
$$
LOC(a_{i+1})=LOC(a_i)+l
$$
由此，所有数据元素的存储位置均可由第一个数据元素的存储位置得到：（基地址$LOC(a_1)$）
$$
LOC(a_i)=LOC(a_1)+(i-1)\times l
$$


### 优缺点



- 优点：
  - 存储密度大（结点本身所占存储量/结点结构所占存储量）
  - 可以随机存取表中任一元素
- 缺点：
  - 在插入、删除某一元素时，需要移动大量元素
  - 浪费存储空间
  - 属于静态存储形式，数据元素的个数不能自由扩充



## 线性表的链式表示和实现



### 链式存储结构



- 节点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻
- 线性表的链式表示又称为非顺序映象或链式映象
- 用一组物理位置任意的存储单元来存放线性表的数据元素
- 这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的
- 链表中元素的逻辑次序和物理次序不一定相同



### 与链式存储有关的术语



1. 结点：数据元素的存储映像。由数据域和指针域两部分组成。
2. 链表：n个结点由指针链组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。



### 单链表、双链表、循环链表



- 结点只有一个指针域的链表，称为单链表或线性链表
- 结点有两个指针域的链表，称为双链表
- 首尾相接的链表称为循环链表



### 头指针、头结点、首元结点



![image-20210918212228027](/Users/jiyuan/Library/Application%20Support/typora-user-images/image-20210918212228027.png)



头指针：是指向链表中第一个节点的指针，有头结点指向头结点，没有头结点指向首元结点

首元结点：是指链表中存储第一个数据元素$a_1$的节点

头结点：是在链表的首元结点之前附设的一个节点（带头结点）

无头结点时，头空指针为空时表示空表；有头结点时，当头结点的指针域为空时表示空表。



**在链表中设置头结点有什么好处？**

1. 便于首元结点的处理首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理
2. 便于空表和非空表的统一处理无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了



### 链表（链式存储结构）特点



1. 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。
2. 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等。
