---
title: 浏览器问题
tags:
   - 面试
createTime: 2021/11/07
permalink: /article/3wps6fp6/
---
**浏览器可以同时打开多个同域名页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？**

端口一样的，网络进程知道每个TCP连接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。



**TCP传送数据时，浏览器端就做渲染处理了么？如果前面数据包丢了，后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？**

接收到http响应头中的content-type类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做DOM解析了！基于http不用担心数据包丢失的问题，因为丢包和重传都是在tcp层解决的。http能保证数据按照顺序接收的（也就是说，从tcp到http的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染） 



**http 和 websocket都是属于应用层的协议吗？**

都是应用层协议，而且websocket名字取的比较有迷惑性，其实和socket完全不一样，可以把websocket看出是http的改造版本，增加了服务器向客户端主动发送消息的能力。



**建立一个tcp连接，可以处理多个请求吗？**

http/1.1 一个tcp同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！

但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求！

不过http2是可以并行请求资源的，所以如果使用http2，浏览器只会为每个域名维护一个tcp连接。



**http2同个域名只能维持一个长连接。那我现在打开了一个域名下的a页面，然后又打开了这个域名的b页面，那这个b页面是新开一个tcp长连接吗？还是会用a页面的长连接？**

浏览器为用同一个域名只维护一个TCP连接。

通过Chrome打开`chrome://net-export/ `这个地址，然后记录网络过程。

最后在使用这个`https://netlog-viewer.appspot.com/ `打开你日志文件，就能看到h2的详细信息了。



**http的keep alive和http2中的信道复用有什么区别？**

一个http中的keep-alive是排队请求，也就是一个http请求完成之后才能继续请求下一个，而http2中请求是并发的，可以同时处理很多请求！



**浏览器请求页面时，各个进程间是怎么配合的？**

1. 用户输入url并回车。
2. 用户输入URL，**浏览器进程**会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，**浏览器进程**就会根据URL协议，在这段内容上加上协议合成合法的URL。
3. 浏览器导航栏显示loading状态，但是页面还是呈现之前的页面不变，因为新页面的响应数据还没有获得。
4. **浏览器进程**构建请求行信息，通过进程间通信（IPC）把url请求发送给**网络进程**
5. **网络进程**接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给**浏览器进程**
6. 如果没有，**网络进程**向web服务器发起http请求（网络请求），请求流程如下：
   1. 进行DNS解析，获取服务器ip地址
   2. 利用ip地址和服务器建立tcp连接
   3. 完成构建请求信息并发送请求
   4. 服务器响应后，**网络进程**接收响应头和响应信息，并解析响应内容
7. **网络进程**解析响应流程：
   1. 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步，如果是200，则继续处理请求。
   2. 检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html等资源则将其转发给**浏览器进程**。
8. **浏览器进程**接收到网络进程的响应头数据之后，检查当前url是否和**之前打开的渲染进程**根域名是否相同，如果相同，则复用原来的进程，如果不同，则**开启新的渲染进程**。
9. **渲染进程**准备好后，**浏览器进程**发送`CommitNavigation`消息到**渲染进程**，发送`CommitNavigation`时会携带响应头、等基本信息。**渲染进程**接收到消息和**网络进程**建立传输数据的“管道”。
10. **渲染进程**接收完数据后，向**浏览器进程**发送“确认提交”。
11. **浏览器进程**接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。



**浏览器的http的keepalive是什么复用程度？**

首先keep-alive是为了解决连接效率不高的问题，http1.0时代，http请求都是短连接的形式，也即是每次请求一个资源都需要和服务器建立连接+传输数据+断开连接，通常，建立连接和断开连接的时间就有可能超过传输数据的时间了，这种短连接的效率是异常的低效。

针对短连接低效的问题，后面就出现了长连接，也就是这里要讲的keep-alive。

你可以把长连接看成是一个管道，一个http请求结束之后，不会关闭连接，下个请求可以复用该连接，这样就省去建立连接和断开连接的时间了，但是他们请求是按照顺序，也就是符合IP+端口规则的资源都可以复用该连接，这就回答了上面提的这个问题。

但是，使用keep-alive同样存在问题，比如一个页面可能有100张图片素材，假设这些图片素材都保存在同一个域名下面，如果只复用一个http管道的话，那么传输100张图片的素材也是非常耗时间的，这就出现了同一时刻并发连接服务器的需求，也就是文中提到同一时刻，对同一域名下面，只能可以发起6个请求，这样就可以大大提升请求效率了。

为什么是6个请求而不是更多了，这是为了服务器性能考虑，如果同一时刻无限制连接，那么可能会导致服务器忙不过来。



**如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？**

当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：

```html
<html>     
  <body>         
    极客时间         
    <script>         
      document.write("--foo")         
    </script>     
  </body> 
</html>
```

那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。  那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：

```html
 <html>     
   <body>         
     极客时间         
     <script type="text/javascript" src="foo.js"></script>     
   </body> 
</html>
```

这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。  我们再看第三种情况，还是看下面代码： 

```html
<html>     
  <head>         
    <style type="text/css" src = "theme.css" ></style>     
  </head>     
  <body>         
  	<p>极客时间</p>         
  	<script>
      let e = document.getElementsByTagName('p')[0]             
      e.style.color = 'blue'         
    </script>     
  </body> 
</html> 
```

当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。



**浏览器的渲染流程是什么？**

1. 渲染进程将 HTML 内容转换为能够读懂的 **DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 **styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
7. 合成线程发送绘制图块命令 **DrawQuad** 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。



**为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？**

重排需要更新完整的渲染流水线，所以开销也是最大的。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

减少重排重绘, 方法很多：

1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化



**渲染进程里的input标签上传图片，通过与浏览器主进程通信，主进程读取硬磁盘图片数据返回给渲染进程，渲染进程里的js发起ajax请求，是通过浏览器主进程去调用网络进程发起请求，还是渲染进程可以直接调用网络进程发起请求？**

`XMLHttpRequest` 可以直接走网络进程，不需要浏览器进程介入。



**请求长时间处于pending状态或者脚本执行死循环，这时刷新或前进后退页面不响应，刷新或前进后退页面是属于浏览器主进程的UI交互行为，为什么渲染进程里的js引擎执行会影响到主进程？**

因为前进或者后退也需要执行当前页面脚本，比如要执行`beforeunload`事件，执行的时候页面没响应了，所以前进后退也就失效了。



**V8编译的基本单位是一段JS代码（内敛JS）或者一个JS文件吗(还是以当前调用栈将要执行函数为单位）？**

全局代码，或者函数 ！

比如下载完一个js文件，先编译这个js文件，但是js文件内定义的函数是不会编译的。

等调用到该函数的时候，Javascript引擎才会去编译该函数！



**为什么代码执行时间越长，执行效率越高？**

随着v8执行，热点代码会越来越来越多，`turbofan`将热点代码转换为机器码，以哈希表形式存在堆内存中的，会占据越来越多的内存。



**为什么用CSS3实现动画效率会比JS实现来的高？**

部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重排和重绘的过程，这就大大提升了渲染效率。

JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！



**为什么渲染进程中有多个线程在工作，却说JS是单线程的呢？**

虽然浏览器是基于多进程+多线程架构的，但是JavaScript引擎是运行在渲染进程的主线程上的，所以我们说JavaScript是单线程执行的！



**浏览器的事件循环和js event loop是一回事吗？**

JavaScript没有自己循环系统，它依赖的就是浏览器的循环系统，也就是渲染进程提供的循环系统！所以可以说是一回事。



**渲染进程的主线程和V8执行机主线程是同一个线程吗？一个渲染进程有几个线程，分别有啥作用？**

主要有IO线程，用开负责和其它进程IPC通信的，然后主线程主要跑页面的！

V8是在主线程上执行的，因为dom操作啥的都是在主线程上执行的。

当然还有其它很多辅助线程，比如预解析DOM的线程，垃圾回收也有一些辅助线程。

