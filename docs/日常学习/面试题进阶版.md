---
title: 面试题进阶版
tags:
  - 笔记
  - 学习
  - 面试
createTime: 2023/02/14
permalink: /article/9q0zhe0v/
---
#### vue是怎么解析template的？

vue会首先将template编译成渲染函数，渲染函数会根据当前的数据来渲染虚拟Dom，然后将渲染出来的虚拟Dom结构转换成真实dom结构，最后更新到页面中。



#### vue的render和template有什么关系？

在Vue中，模板（template）和渲染函数（render function）都可以用于定义组件的渲染输出。

模板是一种基于HTML语法的标记语言，通过在模板中使用特定的Vue指令，可以将数据绑定到DOM元素上，实现动态渲染。

渲染函数是一个JavaScript函数，它接收一个参数h（也可以是createElement），并返回一个VNode（虚拟节点）对象，它描述了组件的DOM结构和属性。

Vue会将模板编译成渲染函数，最终生成VNode并渲染到DOM中。在运行时，Vue会优先使用渲染函数进行渲染，而不是直接使用模板。

因此，渲染函数和模板都用于定义组件的渲染输出，但它们的语法和用法有所不同，最终都会被编译成VNode并渲染到页面上。



#### vue 和 react 在虚拟dom的diff上，做了哪些改进使得速度很快?

Vue和React都采用了虚拟DOM（Virtual DOM）来优化页面更新的性能。

在虚拟DOM的实现中，当组件的状态发生改变时，会先生成新的虚拟DOM树，然后通过算法对比新旧虚拟DOM树的差异（Diff算法），最后只对差异部分进行DOM操作，从而减少了页面的重绘和回流，提高了渲染性能。

在虚拟DOM的Diff算法实现中，Vue和React都做了许多优化，具体包括：

1. 使用高效的算法：Vue和React都采用了高效的Diff算法，例如React采用了Fiber算法，Vue采用了snabbdom算法。
2. 将Diff过程拆分为多个阶段：Vue和React都将Diff过程拆分为多个阶段，从而实现异步更新和优先级控制，使得页面的更新更加流畅和高效。
3. 减少Diff次数：Vue和React都尽可能地减少Diff的次数，例如React采用了shouldComponentUpdate生命周期钩子函数和PureComponent等优化技巧，Vue采用了watcher队列和异步更新等技巧，从而减少了页面的更新次数。
4. 优化Diff的过程：Vue和React都优化了Diff的过程，例如React采用了Diff策略，对比同级节点和Key，Vue采用了Diff算法中的Patch算法，从而减少了Diff的时间复杂度。

总之，Vue和React在虚拟DOM的Diff算法上都做了许多优化，从而实现了高效的页面更新和渲染性能。



#### vue 向 react迁移是怎么做的？怎么保证兼容的？

将Vue迁移至React是一项非常具有挑战性的任务，因为两个框架的设计理念、语法和生态系统都有很大的差异。以下是一些可能的迁移策略：

1. 逐步替换：将Vue应用程序分解成多个组件，然后逐步用React重写这些组件。可以使用Vue和React的混合模式，将React组件嵌入到Vue组件中，并逐步将Vue的功能迁移到React中。
2. 使用Vue2React：Vue2React是一个开源工具，它提供了一组API来使Vue组件在React应用程序中可用。可以使用Vue2React将Vue组件转换为React组件，从而实现逐步替换。
3. 使用类似中间件的工具：有一些工具，如Vue-Rx和Vue-Redux，可以将Vue组件与React Redux或RxJS等库结合使用。可以使用这些工具，将Vue组件转换为React Redux或RxJS中的组件，并逐步替换。

在迁移过程中，为了确保兼容性，需要注意以下几点：

1. 保持数据模型的一致性：Vue和React有不同的状态管理机制，需要保证数据模型在两个框架中的结构和内容是一致的，以避免在迁移过程中出现错误。
2. 保持组件接口的一致性：Vue和React有不同的组件接口，需要保持组件接口在两个框架中的一致性，以便在迁移过程中不会对组件接口造成太大的影响。
3. 逐步迁移：为了避免在迁移过程中出现过多的问题，可以采用逐步迁移的策略，先迁移部分组件，测试并验证其正确性，然后再继续迁移其他组件。



#### react和vue在技术层面的区别有哪些？

React和Vue是两个流行的前端JavaScript框架，它们在技术层面上有以下一些区别：

1. 组件化：React和Vue都采用组件化开发方式，但它们的组件实现方式不同。React的组件是基于JSX语法和函数式编程，而Vue的组件则使用模板和声明式语法。
2. 数据绑定：Vue使用双向数据绑定，可以实现模板和数据之间的自动同步。React则采用单向数据流，只能通过props向子组件传递数据，并使用状态(state)来管理组件内部的数据。
3. 虚拟DOM：React和Vue都使用虚拟DOM来提高性能。虚拟DOM是在内存中创建一个轻量级的DOM树，用于描述真实DOM的结构和状态。当数据发生变化时，React和Vue都会对虚拟DOM进行比较，并只更新必要的部分。
4. 生命周期：React和Vue都有组件生命周期函数，但它们的名称和调用时机有所不同。React的生命周期函数包括componentDidMount、componentDidUpdate和componentWillUnmount等；Vue的生命周期函数包括beforeCreate、created和beforeDestroy等。
5. 代码复用：Vue提供了mixin和自定义指令等机制，可以在多个组件之间复用代码。React则通过高阶组件(HOC)和render props等技术实现组件的代码复用。
6. 性能优化：React和Vue都有相关的性能优化技术。React采用的是PureComponent、shouldComponentUpdate等方式进行组件的性能优化，而Vue采用的是计算属性和watcher等技术来提高渲染效率。

总体而言，React和Vue在技术层面上有一些区别，但它们都是优秀的框架，可以根据项目需求和个人喜好进行选择。



#### js中的storage在浏览器中是怎么存储的？

在浏览器中，JavaScript中的Storage API（即localStorage和sessionStorage）是使用浏览器的本地存储机制来存储数据的。

本地存储指的是将数据存储在用户的本地设备上，以便在用户下一次访问相同的网站时可以快速读取这些数据。常见的本地存储机制有两种：cookie和Web Storage。

Storage API使用的是Web Storage机制，它通过localStorage和sessionStorage提供了一个简单的键值对存储方式，可以存储字符串类型的数据。localStorage和sessionStorage的区别在于，localStorage存储的数据没有过期时间，而sessionStorage存储的数据在当前会话结束时会被清除。

在存储数据时，浏览器会将数据以键值对的形式存储在用户的本地设备上，一般是存储在磁盘上的某个文件中。当需要读取数据时，浏览器会从该文件中读取数据并返回给JavaScript程序。

需要注意的是，由于localStorage和sessionStorage存储在用户本地设备上，因此存储的数据可能会受到一些限制，例如存储容量、隐私和安全等方面的限制。



#### webscoket的连接原理是什么？

WebSocket是一种基于TCP协议的全双工通信协议，可以在浏览器和服务器之间建立双向的通信连接。其连接原理可以概括为以下几个步骤：

1. 握手：客户端向服务器发起一个HTTP请求，请求头包含特殊的Upgrade头和Connection头，请求体为空。服务器收到请求后进行验证，并返回101状态码和升级头（Upgrade header）和连接头（Connection header）。
2. 建立连接：客户端和服务器在完成握手之后，会建立一个TCP连接。该连接会一直保持打开状态，以便后续通信的进行。
3. 数据传输：客户端和服务器在建立连接之后，可以通过该连接发送消息。消息可以是文本或二进制格式，它们以帧（frame）的形式进行传输。
4. 关闭连接：当客户端或服务器需要关闭连接时，可以发送一个特殊的关闭帧，该帧会告知对方关闭连接。客户端和服务器会在接收到关闭帧后，关闭连接并释放资源。

在WebSocket连接中，客户端和服务器可以随时发送消息，无需等待对方的响应。这种双向的通信方式可以用于实时通信、游戏、股票行情等需要实时更新的应用场景。



#### js里this的设计怎么样? 

JavaScript中的this设计是为了提供一种简洁、灵活的方法来引用当前对象或执行上下文的引用。

this在JavaScript中是一个关键字，它的值根据调用方式和上下文环境的不同而变化。通常情况下，this指向的是调用该函数的对象或执行上下文。例如，在对象的方法中，this指向该对象；在全局上下文中，this指向全局对象。

JavaScript的this设计的优点在于它提供了一种方便的方法来引用当前对象或执行上下文。在面向对象编程中，this可以用来引用当前对象，从而实现数据的封装和方法的调用。在函数式编程中，this可以用来引用当前执行上下文，从而实现函数的柯里化和绑定等操作。

然而，JavaScript的this也容易引起混淆和错误。由于this的值在运行时动态确定，因此需要在编写代码时仔细考虑上下文和调用方式，以避免this指向不当的情况。为了避免this的混乱，建议使用箭头函数、call、apply、bind等方法来改变this指向，也可以使用变量保存this，以便在需要的时候使用。



#### 导致js里this指向混乱的原因是什么?

在JavaScript中，this指向混乱通常是由以下原因造成的：

1. 函数调用方式的不同：当函数作为对象的方法被调用时，this指向该对象；当函数作为普通函数被调用时，this指向全局对象（在浏览器中是window）。可以通过使用call、apply、bind等方法来改变函数的this指向。
2. 事件处理函数中的this：当使用addEventListener等方法为DOM元素绑定事件处理函数时，this指向该元素。
3. 箭头函数的this：箭头函数的this指向外层作用域中的this，而不是指向函数自身的this。箭头函数通常用于解决回调函数中this指向混乱的问题。
4. 定时器中的this：在定时器中，this指向的是全局对象，而不是定义定时器的对象。
5. 在类中使用this：在ES6中，class关键字被引入，使用class定义的类中的this指向类的实例对象。

为了避免this指向混乱，可以使用箭头函数、call、apply、bind等方法来改变this指向，也可以使用变量保存this，以便在需要的时候使用。此外，在编写代码时，建议使用严格模式（strict mode），该模式可以帮助检测和解决一些常见的this指向问题。



#### generator 是如何做到中断和恢复的？

在JavaScript中，Generator是一种特殊的函数，它可以通过yield关键字将执行过程中的控制权交出去，从而实现中断和恢复。

具体来说，Generator在执行时会返回一个迭代器对象，该对象具有next方法和value属性。调用迭代器的next方法时，Generator函数会从上次执行的yield语句开始执行，直到下一个yield语句或函数结束为止，然后将执行结果通过value属性返回给调用者。在下一次调用next方法时，Generator会从上一次执行的yield语句后面继续执行，直到遇到下一个yield语句或函数结束。

通过yield语句，Generator可以将执行过程中的控制权交出去，并保存函数的执行状态。这样，在下一次调用next方法时，Generator函数就可以从上一次执行的状态继续执行，从而实现了中断和恢复。

需要注意的是，Generator函数在执行时不会阻塞整个线程，而是会将执行权交给其他任务，因此可以用于异步编程。此外，由于Generator可以多次中断和恢复，因此可以用于实现状态机和协程等功能。



#### 什么是js的作用域链？

JavaScript的作用域链（Scope Chain）是指由当前执行上下文中的变量对象和所有外部环境的变量对象组成的链式结构。作用域链用于解析标识符，即在当前上下文中查找变量或函数的值。

当JavaScript代码在一个执行上下文中执行时，它会先在当前上下文的变量对象中查找变量或函数，如果找不到，就会到它的父级上下文中继续查找，直到找到全局上下文，即全局变量对象为止。这样就形成了一个作用域链。作用域链的顶端是当前执行上下文的变量对象，底端是全局上下文的变量对象。

在作用域链中，每个变量对象都有一个对外部环境的引用，称为“外部环境的引用”或“作用域链指针”。通过这个引用，JavaScript可以在当前执行上下文中访问外部环境中的变量或函数。

作用域链的构建是在函数定义时确定的，而不是在函数调用时确定的。每个函数都有自己的作用域链，当函数被调用时，它的作用域链就会被创建。当函数执行完毕后，其作用域链就会被销毁。

作用域链是JavaScript语言中重要的概念之一，它影响了JavaScript程序的执行过程和性能。了解作用域链的原理和构成，可以帮助开发者更好地理解JavaScript程序的执行过程，从而编写出更加健壮、高效的代码。



#### 闭包是什么？有哪些用途？

在 JavaScript 中，闭包是指由函数和其相关引用组成的组合体，这些引用可以访问在函数定义时所处的作用域中的变量和参数。简单来说，闭包是指函数能够“记住”并访问在其定义时的作用域中的变量和参数，即使在函数执行后，这些变量和参数的作用域已经消失。

闭包的用途很广泛，以下是一些常见的应用场景：

1. 封装私有变量：由于 JavaScript 中没有原生支持私有变量的概念，可以使用闭包来模拟私有变量，即将变量保存在函数作用域中，从而防止其被外部访问和修改。
2. 实现模块化：利用闭包的特性，可以将一组相关的函数和变量组织成一个模块，从而实现模块化编程。
3. 缓存函数计算结果：有些函数可能需要进行耗时的计算，而这些计算结果可能会被多次使用。利用闭包可以将计算结果缓存起来，避免重复计算，提高性能。
4. 实现函数柯里化：函数柯里化是指将接受多个参数的函数转化为接受单个参数的函数序列的过程。利用闭包可以轻松实现函数柯里化。
5. 实现回调函数：在异步编程中，可以使用闭包将回调函数作为参数传递给异步函数，从而在异步函数执行完毕后执行回调函数。

总的来说，闭包是 JavaScript 中一个非常重要的概念，可以帮助我们实现许多有用的功能和模式。但是过度使用闭包也可能导致内存泄漏等问题，需要合理使用。



#### 小程序的架构是什么样的？

小程序的架构可以大致分为两个部分：客户端和服务器。

在客户端方面，小程序的架构通常采用MVVM（Model-View-ViewModel）的设计模式。其中，View层负责显示用户界面，ViewModel层负责管理数据和业务逻辑，Model层则负责与服务器进行交互。在小程序中，View和ViewModel通常由框架提供，而开发者需要实现Model层的逻辑。

小程序的客户端架构还包括以下组件：

1. 页面：页面是小程序的基本单位，每个页面对应一个WXML文件、一个WXSS文件和一个JavaScript文件。页面可以通过路由进行跳转。
2. 组件：组件是小程序的可复用模块，由WXML、WXSS和JavaScript三部分组成。组件可以通过slot和props等方式实现数据的传递和共享。
3. API：API是小程序提供的一组接口，可以实现诸如网络请求、本地存储、媒体播放等功能。

在服务器方面，小程序通常需要与后端进行数据交互。后端可以提供RESTful API或GraphQL等方式进行数据传输。在小程序中，也可以使用云开发平台提供的BaaS（Backend as a Service）服务进行开发，以实现数据存储、云函数等功能。

总之，小程序的架构以MVVM为基础，通过页面、组件和API等方式构建客户端，通过与后端进行数据交互实现全栈开发。



#### 为什么小程序里拿不到dom相关的api？

小程序里不能直接使用DOM相关的API是因为小程序的运行环境和Web环境有所不同。

小程序的运行环境是一个独立的JavaScript虚拟环境，它在底层使用的是WebView或JSBridge技术实现的。与Web环境相比，小程序的运行环境对DOM、BOM等Web API的支持有限。由于小程序的安全机制和跨平台特性，小程序的运行环境限制了开发者直接访问和操作底层的DOM元素和浏览器对象。

在小程序中，视图层采用的是WXML和WXSS语言，用于描述页面和样式，可以与JavaScript文件进行交互，但不能直接操作底层的DOM元素和浏览器对象。为了弥补这一限制，小程序提供了一系列的组件和API，用于实现类似的功能，如事件绑定、样式设置、动画效果、数据绑定、数据存储等。开发者可以通过小程序提供的API和组件来实现丰富的应用功能。

总之，小程序的设计目标是轻量化、快速开发、易维护，因此限制了对底层DOM相关API的访问。开发者应该采用小程序提供的方式来实现应用功能，以达到最佳的用户体验和应用性能。



#### 小程序为什么会有两个线程？

小程序为了提高性能和用户体验，采用了双线程架构。它的设计是基于微信客户端的WebView技术实现的。

具体来说，小程序的双线程架构由两个线程组成：一个是UI线程（也叫主线程），负责处理用户交互和渲染页面；另一个是JS线程（也叫工作线程），负责处理小程序的逻辑和数据。这两个线程之间通过WebView提供的JavaScriptCore与WebCore两个组件之间的消息机制进行通信。

在小程序的设计中，UI线程和JS线程是相互独立的，它们之间没有共享的数据。UI线程只处理页面渲染和用户事件响应，JS线程只负责逻辑处理和数据管理。这样做的好处是可以避免页面卡顿和性能问题，提高小程序的运行效率和用户体验。

小程序的双线程架构也带来了一些挑战，比如如何保持UI线程和JS线程之间的同步和通信、如何确保线程安全等问题。为了解决这些问题，小程序提供了一些特殊的API和机制，如setData()方法、WXS脚本、事件机制等，让开发者可以更加方便地编写小程序。

总之，小程序的双线程架构是为了提高性能和用户体验而设计的，它的实现依赖于微信客户端的WebView技术，通过UI线程和JS线程的分离和通信，实现了小程序的快速、高效运行。



#### 截图怎么实现？

在 Web 开发中，实现截图功能可以使用 JavaScript 和 HTML5 提供的 Canvas API。

以下是实现截图的简要步骤：

1. 获取需要截图的元素：可以使用 document.getElementById() 或 document.querySelector() 等方法获取需要截图的元素。
2. 创建一个 canvas 元素：使用 document.createElement() 创建一个 canvas 元素，并设置其宽度和高度与要截图的元素相同。
3. 获取 canvas 的上下文对象：使用 canvas.getContext() 获取 canvas 的上下文对象，用于在 canvas 上绘制图像。
4. 将要截图的元素绘制到 canvas 上：使用上下文对象的 drawImage() 方法将要截图的元素绘制到 canvas 上。
5. 获取 canvas 的图像数据：使用 canvas.toDataURL() 方法获取 canvas 上的图像数据，即截图结果。

以下是一个简单的实现截图的示例代码：

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>截图示例</title>
  </head>
  <body>
    <div id="screenshot-target">
      <p>需要截图的元素</p>
    </div>
    <button onclick="takeScreenshot()">截图</button>
    <script>
      function takeScreenshot() {
        // 获取需要截图的元素
        var target = document.getElementById('screenshot-target');
        // 创建一个 canvas 元素
        var canvas = document.createElement('canvas');
        // 设置 canvas 的宽度和高度
        canvas.width = target.clientWidth;
        canvas.height = target.clientHeight;
        // 获取 canvas 的上下文对象
        var context = canvas.getContext('2d');
        // 将要截图的元素绘制到 canvas 上
        context.drawImage(target, 0, 0);
        // 获取 canvas 的图像数据
        var imageData = canvas.toDataURL();
        // 显示截图结果
        alert(imageData);
      }
    </script>
  </body>
</html>

以上代码实现了一个简单的截图功能，点击按钮后会弹出一个包含截图结果的对话框。在实际应用中，可以根据需要将截图结果保存到文件、上传到服务器等。
